# Waybar Fork Management & Development Rules

## 🎯 Project Overview
This is a fork of the upstream Waybar project with custom autohide functionality. The goal is to maintain upstream parity while adding valuable features.

## 🏗️ Repository Structure
- `upstream` → Original Waybar repository (https://github.com/Alexays/Waybar.git)
- `origin` → This fork (https://github.com/Trahloc/waybar-ai)
- `master` → Main branch (upstream + custom features)
- `feature/*` → Feature development branches

## 🔄 Mandatory Workflow Rules

### 1. Feature Development
```bash
# ALWAYS start from master
git checkout master
git pull upstream master  # Get latest upstream changes
git checkout -b feature/descriptive-name

# Work on feature
# ... make changes ...

# Commit with proper messages
git add .
git commit -m "feat: descriptive commit message"

# Push feature branch
git push origin feature/descriptive-name

# Create PR via GitHub CLI
gh pr create --title "feat: Feature Title" --body "Detailed description"
```

### 2. Upstream Sync Process
```bash
# Fetch latest upstream
git fetch upstream

# Create temporary sync branch
git checkout -b upstream-sync
git merge upstream/master

# Test everything works
ninja -C build waybar
# ... run tests ...

# If good, merge to master
git checkout master
git merge upstream-sync
git push origin master

# Clean up
git branch -d upstream-sync
```

### 3. PR Management
- **NEVER** push directly to master (branch protection enabled)
- **ALWAYS** use feature branches for development
- **ALWAYS** create PRs via `gh pr create` or GitHub web interface
- **ALWAYS** test before merging PRs

## 🧩 Code Quality Rules

### 1. Module Development
- Follow waybar's module architecture patterns
- Inherit from `AModule` and implement required methods
- Use proper thread safety with `std::atomic` and `dp.emit()`
- Follow RAII principles for resource management

### 2. Configuration
- All config options must have sensible defaults
- Use `config_["key"].isUInt() ? config_["key"].asUInt() : default_value` pattern
- Document all configuration options in commit messages

### 3. Threading & IPC
- GTK operations MUST be on main thread (use `dp.emit()`)
- Background threads for polling/monitoring only
- Use Hyprland IPC for Wayland-specific functionality
- Set `waybar::modules::hyprland::modulesReady = true` for Hyprland modules

### 4. Error Handling
- Always check for null pointers before use
- Use `spdlog` for logging (appropriate levels: trace, debug, info, warn, error)
- Graceful degradation when external dependencies fail

## 📝 Commit Message Standards
```
feat: Add new feature
fix: Fix bug
refactor: Code refactoring
docs: Documentation changes
test: Add or update tests
chore: Maintenance tasks
```

## 🚫 Forbidden Practices
- Direct pushes to master branch
- Merge commits in feature branches (use rebase)
- Hardcoded values without configuration options
- Memory leaks or resource leaks
- Blocking operations on main thread
- External dependencies without fallbacks

## 🔧 Build & Test Requirements
- Code MUST compile with `ninja -C build waybar`
- No compiler warnings (except external library warnings)
- All features must be testable
- Resource usage must be minimal and justified

## 📋 Pre-PR Checklist
- [ ] Code compiles without errors
- [ ] No compiler warnings (except external)
- [ ] All config options have defaults
- [ ] Thread safety implemented correctly
- [ ] Resource cleanup in destructor
- [ ] Proper error handling
- [ ] Meaningful commit messages
- [ ] Feature branch is up to date with master

## 🎯 Autohide Module Specific Rules
- Mouse tracking via Hyprland IPC only
- Two-consecutive-events requirement for show trigger
- Per-monitor mouse position tracking
- Workspace change detection via Hyprland events
- State machine design (no multiple boolean flags)
- Minimum 10ms delays to prevent race conditions
- Trace-level logging for mouse position (avoid spam)

## 🔄 Regular Maintenance
- Monthly upstream sync (or when important updates available)
- Test all custom features after upstream merges
- Update documentation when adding features
- Clean up old feature branches after merge

## 📚 Documentation Requirements
- README updates for new features
- Inline code comments for complex logic
- Configuration examples in commit messages
- Architecture decisions documented

## 🚨 Emergency Procedures
If master branch gets corrupted:
```bash
git checkout master
git reset --hard upstream/master
git push origin master --force-with-lease
```

## 🎯 Success Criteria
- Upstream parity maintained
- Custom features working correctly
- Clean git history
- Proper PR workflow followed
- Code follows waybar standards
- Minimal resource usage
- Thread-safe implementation
