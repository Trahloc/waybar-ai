---
description: Specific implementation rules for autohide module including mouse tracking, state management, and Hyprland IPC
alwaysApply: false
---
# Autohide Module Specific Rules

## Mouse Tracking
- Use Hyprland IPC only: `m_ipc.getSocket1Reply("cursorpos")`
- Per-monitor mouse position tracking
- Check if mouse is on current monitor before processing
- Convert to monitor-relative coordinates

## State Management
- Use state machine with `enum class WaybarState`
- States: `VISIBLE`, `HIDDEN`, `PENDING_VISIBLE`, `PENDING_HIDDEN`
- Only one state can be true at any time
- No multiple boolean flags

## Show/Hide Logic
- Two-consecutive-events requirement for show trigger
- Mouse Y ≤ 1px: Show waybar (requires two consecutive events)
- Mouse Y > 50px: Hide waybar after configurable delay
- Mouse between 1px-50px: Keep current state

## Workspace Integration
- Implement `EventHandler` interface
- Register for `"workspacev2"` and `"focusedmonv2"` events
- Force waybar visible on workspace changes
- Use `dp.emit()` to trigger updates on main thread

## Timing & Delays
- Minimum 10ms delays to prevent race conditions
- Use `std::chrono::steady_clock` for timing
- Separate timers for show and hide operations
- Reset show trigger flag when mouse moves away

## Logging
- Trace-level logging for mouse position (avoid spam)
- Debug-level for state changes
- Info-level for module initialization
- Warn-level for errors

## Configuration Options
```json
"autohide": {
  "threshold-hidden-y": 1,      // Mouse Y ≤ this shows waybar
  "threshold-visible-y": 50,    // Mouse Y > this hides waybar
  "delay-show": 0,              // Show delay in ms
  "delay-hide": 1000,           // Hide delay in ms
  "check-interval": 100         // Mouse check interval in ms
}
```

## Thread Safety
- Use `std::atomic<WaybarState>` for state
- Use `dp.emit()` for GTK operations on main thread
- Background thread for mouse tracking only
- Proper cleanup in destructor
